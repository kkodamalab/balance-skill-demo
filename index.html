<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<title>COM Balance Recorder</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
body{
  margin:0; background:#111; color:#fff;
  font-family:sans-serif; overflow:hidden;
}
#videoArea{
  position:relative; width:100vw; height:100vh;
}
video,canvas{
  position:absolute; top:0; left:0;
  width:100%; height:100%; object-fit:cover;
}
#panel{
  position:absolute; bottom:10px; left:50%;
  transform:translateX(-50%);
  background:rgba(0,0,0,.7);
  padding:10px 14px; border-radius:10px;
  display:flex; gap:8px; align-items:center;
}
button,select{
  font-size:16px; padding:6px 10px;
}
#info{
  position:absolute; top:10px; left:50%;
  transform:translateX(-50%);
  background:rgba(0,0,0,.6);
  padding:10px 14px; border-radius:10px;
  text-align:center; white-space:pre-line;
}
#countdown{
  position:absolute; top:50%; left:50%;
  transform:translate(-50%,-50%);
  font-size:72px; font-weight:bold;
  background:rgba(0,0,0,.6);
  padding:20px 30px;
  border-radius:20px;
  display:none;
}
#progressWrap{
  position:absolute; top:70px; left:50%;
  transform:translateX(-50%);
  width:80%; height:14px;
  background:#333; border-radius:7px;
}
#progress{
  height:100%; width:0%;
  background:#00ffcc;
  border-radius:7px;
}
#result{
  position:absolute; top:50%; left:50%;
  transform:translate(-50%,-50%);
  background:rgba(0,0,0,.75);
  padding:20px 28px;
  border-radius:16px;
  font-size:20px;
  text-align:center;
  white-space:pre-line;
  display:none;
}
</style>
</head>
<body>

<div id="videoArea">
  <video id="video" autoplay playsinline muted></video>
  <canvas id="canvas"></canvas>
</div>

<div id="info">準備中…</div>
<div id="countdown"></div>
<div id="progressWrap"><div id="progress"></div></div>
<div id="result"></div>

<div id="panel">
  <select id="duration">
    <option value="10">10秒</option>
    <option value="20">20秒</option>
    <option value="30">30秒</option>
    <option value="40">40秒</option>
    <option value="50">50秒</option>
    <option value="60">60秒</option>
  </select>
  <button id="startBtn">Start</button>
  <button id="stopBtn">Stop</button>
</div>

<script type="module">
import {FilesetResolver, PoseLandmarker}
from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

const video=document.getElementById("video");
const canvas=document.getElementById("canvas");
const ctx=canvas.getContext("2d");

const info=document.getElementById("info");
const resultEl=document.getElementById("result");
const countdownEl=document.getElementById("countdown");
const progressEl=document.getElementById("progress");

const startBtn=document.getElementById("startBtn");
const stopBtn=document.getElementById("stopBtn");
const durationSel=document.getElementById("duration");

let recording=false;
let startTime=0;
let totalTime=0;
let timerID=null;
let comLog=[];
let showTrajectory=false;

const avg=(a,b)=>({x:(a.x+b.x)/2,y:(a.y+b.y)/2});

async function setupCamera(){
  const s=await navigator.mediaDevices.getUserMedia({
    video:{facingMode:"user"},audio:false
  });
  video.srcObject=s;
  return new Promise(r=>video.onloadedmetadata=r);
}

const vision=await FilesetResolver.forVisionTasks(
  "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
);
const pose=await PoseLandmarker.createFromOptions(vision,{
  baseOptions:{
    modelAssetPath:
    "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/1/pose_landmarker_full.task"
  },
  runningMode:"VIDEO",numPoses:1
});
await setupCamera();

function computeMetrics(p){
  if(p.length<2) return {sd:0,len:0};
  const mx=p.reduce((s,v)=>s+v.x,0)/p.length;
  const my=p.reduce((s,v)=>s+v.y,0)/p.length;
  const sd=Math.sqrt(
    p.reduce((s,v)=>s+((v.x-mx)**2+(v.y-my)**2),0)/p.length
  );
  let len=0;
  for(let i=1;i<p.length;i++){
    len+=Math.hypot(p[i].x-p[i-1].x,p[i].y-p[i-1].y);
  }
  return {sd,len};
}

function stopRecording(){
  recording=false;
  clearTimeout(timerID);
  progressEl.style.width="0%";
  showTrajectory=true;

  const {sd,len}=computeMetrics(comLog);
  resultEl.textContent=
    `計測結果\n\nCOM SD：${sd.toFixed(1)} px\n軌跡長：${len.toFixed(1)} px`;
  resultEl.style.display="block";
}

function startWithCountdown(){
  resultEl.style.display="none";
  showTrajectory=false;
  let c=5;
  countdownEl.style.display="block";
  countdownEl.textContent=c;

  const iv=setInterval(()=>{
    c--;
    if(c>0){
      countdownEl.textContent=c;
    }else{
      clearInterval(iv);
      countdownEl.style.display="none";
      startRecording();
    }
  },1000);
}

function startRecording(){
  comLog=[];
  recording=true;
  startTime=performance.now();
  totalTime=Number(durationSel.value)*1000;
  timerID=setTimeout(stopRecording,totalTime);
}

startBtn.onclick=startWithCountdown;
stopBtn.onclick=stopRecording;

let lastTime=-1;
function loop(){
  if(video.readyState<2){requestAnimationFrame(loop);return;}
  if(canvas.width!==video.videoWidth){
    canvas.width=video.videoWidth;
    canvas.height=video.videoHeight;
  }
  if(video.currentTime===lastTime){
    requestAnimationFrame(loop);return;
  }
  lastTime=video.currentTime;

  const res=pose.detectForVideo(video,performance.now());

  ctx.save();
  ctx.scale(-1,1);
  ctx.drawImage(video,-canvas.width,0,canvas.width,canvas.height);
  ctx.restore();

  if(showTrajectory && comLog.length>1){
    ctx.strokeStyle="#00ffff";
    ctx.lineWidth=3;
    ctx.beginPath();
    ctx.moveTo(comLog[0].x,comLog[0].y);
    for(const p of comLog) ctx.lineTo(p.x,p.y);
    ctx.stroke();
  }

  if(res.landmarks?.length){
    const lm=res.landmarks[0];
    let s=avg(lm[11],lm[12]);
    let h=avg(lm[23],lm[24]);

    s.x=1-s.x; h.x=1-h.x;
    s.x*=canvas.width; s.y*=canvas.height;
    h.x*=canvas.width; h.y*=canvas.height;

    const cx=(s.x+h.x)/2;
    const cy=(s.y+h.y)/2;

    ctx.fillStyle="red";
    ctx.beginPath();
    ctx.arc(cx,cy,6,0,Math.PI*2);
    ctx.fill();

    if(recording){
      comLog.push({x:cx,y:cy});
      const elapsed=performance.now()-startTime;
      const sec=Math.min(elapsed/1000,totalTime/1000);
      info.textContent=`計測中\n${sec.toFixed(1)} / ${totalTime/1000} 秒`;
      progressEl.style.width=
        `${Math.min(elapsed/totalTime*100,100)}%`;
    }
  }

  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
